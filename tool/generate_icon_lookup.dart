// ignore_for_file: avoid_print
//
// Generates the Icons String -> IconData lookup table by parsing
// Flutter SDK's material/icons.dart.
//
// Run from project root: dart run tool/generate_icon_lookup.dart
// Or: dart run tool/generate_icon_lookup.dart --flutter-sdk=/path/to/flutter
//
// Requires Flutter SDK path (env FLUTTER_ROOT, .fvm/flutter_sdk, or --flutter-sdk).

import "dart:io";

void main(List<String> args) {
  final flutterRoot = _findFlutterSdk(args);
  if (flutterRoot == null || flutterRoot.isEmpty) {
    print(
      "Usage: dart run tool/generate_icon_lookup.dart [--flutter-sdk=/path]",
    );
    print("Or set FLUTTER_ROOT, or run from project with .fvm/flutter_sdk");
    exit(1);
  }

  final iconsPath = File(
    "$flutterRoot/packages/flutter/lib/src/material/icons.dart",
  );
  if (!iconsPath.existsSync()) {
    print("Not found: ${iconsPath.path}");
    exit(1);
  }

  final content = iconsPath.readAsStringSync();
  final iconNames = _parseIconNames(content);
  if (iconNames.isEmpty) {
    print("No icon names parsed.");
    exit(1);
  }

  _generateLookupTable(iconNames);
}

String? _findFlutterSdk(List<String> args) {
  for (final a in args) {
    if (a.startsWith("--flutter-sdk=")) {
      return a.substring("--flutter-sdk=".length).trim();
    }
  }
  final fromEnv = Platform.environment["FLUTTER_ROOT"];
  if (fromEnv != null && fromEnv.isNotEmpty) return fromEnv;
  final fvm = File(".fvm/flutter_sdk");
  if (fvm.existsSync()) {
    final p = fvm.resolveSymbolicLinksSync();
    if (p.isNotEmpty) return p;
    return ".fvm/flutter_sdk";
  }
  final fvmLink = Link(".fvm/flutter_sdk");
  if (fvmLink.existsSync()) {
    return fvmLink.resolveSymbolicLinksSync();
  }
  return null;
}

final _pattern = RegExp(
  r"static\s+const\s+IconData\s+(\w+)\s*=\s*IconData\(",
);

List<String> _parseIconNames(String content) {
  const beginMarker = "// BEGIN GENERATED ICONS";
  const endMarker = "// END GENERATED ICONS";
  final begin = content.indexOf(beginMarker);
  final end = content.indexOf(endMarker);
  if (begin < 0 || end < 0 || end <= begin) {
    return [];
  }
  final section = content.substring(begin, end);
  final names = <String>{};
  for (final m in _pattern.allMatches(section)) {
    names.add(m.group(1)!);
  }
  return names.toList()..sort();
}

void _generateLookupTable(List<String> iconNames) {
  final buffer = StringBuffer();
  buffer.writeln('part of "data_source.dart";');
  buffer.writeln();
  buffer
      .writeln("/// Lookup table for [IconData] values by [String] type key.");
  buffer.writeln("///");
  buffer.writeln(
    "/// Maps string identifiers (names of [Icons] static members) to [IconData].",
  );
  buffer.writeln(
    '/// Keys: icon name (e.g. "add", "search") and "Icons.<name>" form.',
  );
  buffer.writeln(
    "/// Generated by tool/generate_icon_lookup.dart â€” do not edit by hand.",
  );
  buffer.writeln("const _iconDataStringLookupTable = <String, IconData>{");
  for (final name in iconNames) {
    buffer.writeln('  "$name": Icons.$name,');
  }
  buffer.writeln("};");

  final outPath = "lib/src/view_attributes/icon_lookup.g.dart";
  File(outPath).writeAsStringSync(buffer.toString());
  print(
    "Wrote $outPath (${iconNames.length} icons, ${iconNames.length * 2} entries).",
  );
}
